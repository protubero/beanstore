# BeanStore - Persistent Java Bean Store


BeanStore provides a data storage option when simplicity and flexibility are the primary requirements. All data is held in memory as immutable Java Beans. Changes to the data are expressed as transactions. If a transaction has been successfully applied to the store it is written to a transaction log. When the store starts up the next time the stored transactions are applied sequentially to an empty store to recover the last state of the store. If that reminds you on <i>event sourcing</i>, you got the idea.

BeanStore should fit perfectly if one tries to quickly put together a little web application. On the client side you usually choose a JS lib like vue or svelte but on the server side you want to stick with good ole' java. There are plenty of good and simple web server libs available, like Javalin for example. But when it comes to data persistence there is nothing that fits really well. Here comes BeanStore for the rescue.

Unique selling points:

* The data is persisted in one file
* Everything is in memory, query your data with java streams
* Ensure Constraints with synchronous transaction Listeners
* Bean Validation
* Migrate persistent data with Migration Transactions
* CQRS Read Models through asynchronous transaction listeners
* Configurable full text search with Lucene
* full change history
* Plugin interface

We use *Kryo* to serialize and deserialize Java Beans, *ByteBuddy* to enhance bean classes at runtime and *PCollections* to facilitate concurrent reading and writing.


## Getting Started

### Add maven dependency

```xml
<dependency>
    <groupId>de.protubero</groupId>
    <artifactId>beanstore</artifactId>
    <version>0.8.0</version>
</dependency>
```


### Quickstart Code

```java
@Entity(alias = "todo")
public class ToDo extends AbstractEntity {

	private String text;

	public String getText() {
		return text;
	}

	public void setText(String text) {
		this.text = text;
	}
}

BeanStoreFactory factory = BeanStoreFactory.of(new File("c:/your/path/app.kryo"));
factory.registerType(ToDo.class);
var store = factory.create();
var tx = store.transaction();
		
ToDo newToDo = tx.create(ToDo.class);
newToDo.setText("Hello World");
tx.execute();	

var allToDos = store.reader().objects(ToDo.class).collect(Collectors.toList());
```


### Example Web Application

The [BeanStore Demo](https://github.com/protubero/beanstore-demo) demonstrates the features and typical use cases of the lib.

## Documentation

### BeanStore Java Beans

#### Parent class
A BeanStore entity class has to extends class *AbstractEntity*. It must have a no-arg constructor and expose its properties view setters and getters - as required by the Java Beans Spec. Deviating from the specification, it does not have to be serializable. Each entity is associated with a unique *alias*. Annotate an entity class with an *Entity* annotation to assign an alias. The *key* of a bean is always a long value, stored in the *id* field of *AbstractEntity*. IDs are automatically generated by BeanStore for newly created beans. The id is unique per entity. The *full* key of a BeanStore instance is a combination of alias and id.

Do not declare your bean classes *final*. BeanStore uses ByteBuddy to dynamically create subclasses of your beans. Which will not work with final classes.

#### Map access
The *AbstractEntity* class implements a *Map* interface to make the bean properties accessible in a generic way. The methods of the interface are only partly supported, unsupported operations are: *containsValue*, *remove*, *clean*, *values*.


#### Immutability

The BeanStore is designed as a store of immutable objects. Stored beans will throw an exception if you call a setter method. To set new property values on a bean, a transactions clones a stored bean into a mutable version of the instance. The property values should also be immutable. If mutable types are used you should.

### BeanStore Factory

Use *BeanStoreFactory* to configure the resulting BeanStore:

* register entity classes
* register plugins
* configure migration transactions
* register callback to initialize an empty store


#### Register Entity Classes


#### Initialization of a new Store

#### Migration Transactions


### Writing Data

sequentially

#### Optimistic Locking

#### Pessimistic Locking


### Transaction Listeners

Transactions can be verified by callback code to enforce constraints. The beans can also define constraints by using the Java Bean Validation annotations.

Other callback options allow listeners to be informed on any change to the store, synchronously or asynchronously to the transaction execution. These callbacks can be used to create CQRS style *Read Models*.

All transactions are applied sequentially to the store. Synchronous listeners will receive the change events when an transaction is applied and before the execution code returns. Only verification listeners can abort a transaction by throwing an exception. Execptions from other listener types will only be logged. Asynchronous listeners will receive the change events afterwards but also always in the order of their execution.


### Reading Data

### find and query instances

### Snapshots

### Closing BeanStore


### Plugins

BeanStore plugins 

Implement interface `BeanStorePlugin` to 

before factory.create!

```java
var plugin = new BeanStorePlugin() {
	public void onOpenFile(File file) {
		System.out.println("");
	}
};
beanStoreFactory.addPlugin(plugin);


```

#### Fulltext search

The class `BeanStoreSearchPlugin` adds full text search capability to the BeanStore lib.

```java
	// configure full text search
	BeanStoreSearchPlugin searchPlugin = new BeanStoreSearchPlugin();
	factory.addPlugin(searchPlugin);
	
	// configure projection from instance to text to be indexed
	searchPlugin.register(todoEntity, todo -> {
		return todo.getText();
	});

	var searchResult = searchPlugin.search("World");	
	
```


#### Bean Validation

[Jakarta Bean Validation](https://beanvalidation.org/) is a Java specification which lets you express constraints on object models via annotations. Register plugin *BeanValidationPlugin* to use this feature.

```java
	class Employee extends AbstractEntity {
		@Min(value = 18, message = "Age should not be less than 18")
		private Integer age;
	}

	// configure Java Bean Validation
	BeanValidationPlugin validationPlugin = new BeanValidationPlugin();
	factory.addPlugin(validationPlugin);

	var employee = tx.create(Employee.class);
	employee.setAge(20);
	tx.execute(); // throws ValidationException
	
```

#### Transaction History

Use *BeanStoreHistoryPlugin* if you need to access a full change history of each instance. The simplistic implementation might consume too many resources in case of larger stores. Use it as a starting point of your refined and optimized solution.


#### Transaction Log

The *BeanStoreTransactionLogPlugin* lets you view all transactions, the transactions initially read as well as all transactions written to the file. *BeanStoreTransactionLogPlugin* listens to the *read* and *write* operations and logs them to a SLF4J Logger.

